using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;

namespace Zonit.Extensions.Tenants.SourceGenerators;

[Generator]
public class TenantSettingsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes that inherit from Setting<T>
        var settingClasses = context.SyntaxProvider
           .CreateSyntaxProvider(
                predicate: static (node, _) => IsCandidateSettingClass(node),
                transform: static (ctx, _) => GetSettingClassInfo(ctx))
            .Where(static info => info is not null);

        // Combine all settings and generate the partial class
        var compilation = context.CompilationProvider.Combine(settingClasses.Collect());

        context.RegisterSourceOutput(compilation, static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsCandidateSettingClass(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDecl
               && classDecl.BaseList != null
               && classDecl.BaseList.Types.Any();
    }

    private static SettingClassInfo? GetSettingClassInfo(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDecl);

        if (symbol is not INamedTypeSymbol classSymbol)
            return null;

        // Check if it inherits from Setting<T>
        var baseType = classSymbol.BaseType;
        if (baseType is null)
            return null;

        // Check if base type is generic Setting<T>
        if (!baseType.IsGenericType || baseType.TypeArguments.Length != 1)
            return null;

        // Check the name of the base type (without namespace first for flexibility)
        var baseTypeName = baseType.ConstructedFrom.Name;
        if (baseTypeName != "Setting")
            return null;

        // Additional check for the namespace
        var baseTypeNamespace = baseType.ConstructedFrom.ContainingNamespace?.ToDisplayString();
        if (baseTypeNamespace != "Zonit.Extensions.Tenants.Abstractions.Models")
            return null;

        var modelType = baseType.TypeArguments[0];

        return new SettingClassInfo(
                    ClassName: classSymbol.Name,
                    ModelTypeName: modelType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat),
                    ModelTypeFullName: modelType.ToDisplayString(),
                    PropertyName: GetPropertyName(classSymbol.Name),
                    FieldName: GetFieldName(classSymbol.Name),
                    Namespace: classSymbol.ContainingNamespace.ToDisplayString()
                );
    }

    private static string GetPropertyName(string settingClassName)
    {
        // Remove "Setting" suffix if exists
        if (settingClassName.EndsWith("Setting"))
        {
            return settingClassName.Substring(0, settingClassName.Length - 7);
        }

        return settingClassName;
    }

    private static string GetFieldName(string settingClassName)
    {
        var propertyName = GetPropertyName(settingClassName);
        return $"_{char.ToLowerInvariant(propertyName[0])}{propertyName.Substring(1)}";
    }

    private static void Execute(Compilation compilation, IEnumerable<SettingClassInfo?> settings, SourceProductionContext context)
    {
        var validSettings = settings.Where(s => s is not null).Cast<SettingClassInfo>().ToList();

        if (validSettings.Count == 0)
            return;

        var source = GenerateTenantSettingsClass(validSettings);
        context.AddSource("TenantSettings.g.cs", source);
    }

    private static string GenerateTenantSettingsClass(List<SettingClassInfo> settings)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("namespace Zonit.Extensions.Tenants;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Provides strongly-typed access to all tenant settings.");
        sb.AppendLine("/// This class is auto-generated by the TenantSettingsGenerator.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public partial class TenantSettings");
        sb.AppendLine("{");

        // Generate fields
        foreach (var setting in settings)
        {
            sb.AppendLine($"    private {setting.ModelTypeName}? {setting.FieldName};");
        }

        sb.AppendLine();

        // Generate properties
        foreach (var setting in settings)
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// Gets the {setting.PropertyName.ToLowerInvariant()} settings.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine($"    public {setting.ModelTypeName} {setting.PropertyName} => {setting.FieldName} ??= provider.GetSetting<{setting.ClassName}>().Value;");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private record SettingClassInfo(
        string ClassName,
        string ModelTypeName,
        string ModelTypeFullName,
        string PropertyName,
        string FieldName,
        string Namespace
    );
}
